# AUTOGENERATED! DO NOT EDIT! File to edit: 04_baseline.ipynb.

# %% auto 0
__all__ = ['vocab', 'metrics_cfg','splitter', 'cfg', 'usm1_err', 'usm2_err', 'usm3_err', 
           'usm4_err', 'combo_err', 'usm1_err_raw', 'usm2_err_raw', 'usm3_err_raw', 'usm4_err_raw', 'usm1_loss', 'usm2_loss', 
           'usm3_loss', 'usm4_loss', 'combo_loss', 'usm_err_raw', 'combo_err_raw', 'c', 'get_image_mask', 'custom_accuracy']

# %% 04_baseline.ipynb 2
from fastai.vision.all import *

# %% 04_baseline.ipynb 10
def splitter(df):
    train = df.index[~df['valid']].to_list()
    valid = df.index[df['valid']].to_list()
    return train, valid

# %% 04_baseline.ipynb 14
vocab=L([['bipolar_dissector', 'bipolar_forceps', 'blank', 'cadiere_forceps', 'clip_applier', 'force_bipolar', 'grasping_retractor', 'monopolar_curved_scissor', 'nan', 'needle_driver', 'permanent_cautery_hook_spatula', 'prograsp_forceps', 'stapler', 'suction_irrigator', 'tip_up_fenestrated_grasper', 'vessel_sealer'],['bipolar_dissector', 'bipolar_forceps', 'blank', 'cadiere_forceps', 'clip_applier', 'force_bipolar', 'grasping_retractor', 'monopolar_curved_scissor', 'nan', 'needle_driver', 'permanent_cautery_hook_spatula', 'prograsp_forceps', 'stapler', 'suction_irrigator', 'tip_up_fenestrated_grasper', 'vessel_sealer'],['bipolar_dissector', 'bipolar_forceps', 'blank', 'cadiere_forceps', 'clip_applier', 'force_bipolar', 'grasping_retractor', 'monopolar_curved_scissor', 'nan', 'needle_driver', 'permanent_cautery_hook_spatula', 'prograsp_forceps', 'stapler', 'suction_irrigator', 'tip_up_fenestrated_grasper', 'vessel_sealer'],['bipolar_dissector', 'bipolar_forceps', 'blank', 'cadiere_forceps', 'clip_applier', 'force_bipolar', 'grasping_retractor', 'monopolar_curved_scissor', 'nan', 'needle_driver', 'permanent_cautery_hook_spatula', 'prograsp_forceps', 'stapler', 'suction_irrigator', 'tip_up_fenestrated_grasper', 'vessel_sealer']])


c=L([len(v) for v in vocab])


# %% 04_baseline.ipynb 19
def cfg (i): return c[:i].sum()

# defining error rate for each robotic hand tools
def usm1_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs): return error_rate(preds[:,:cfg(1)], usm1_targs)
def usm2_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs): return error_rate(preds[:,cfg(1):cfg(2)], usm2_targs)
def usm3_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs): return error_rate(preds[:,cfg(2):cfg(3)], usm3_targs)
def usm4_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs): return error_rate(preds[:,cfg(3):cfg(4)], usm4_targs)

# defining combined error rate 
def combo_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs): 
    return usm1_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs)+usm2_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs)+usm3_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs)+usm4_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs)

# defining error rate for each robotic hand tools for raw preds from the learner 
def usm1_err_raw(preds,targs): return error_rate(preds[:,:cfg(1)].softmax(dim=1).argmax(dim=1), targs)
def usm2_err_raw(preds,targs): return error_rate(preds[:,cfg(1):cfg(2)].softmax(dim=1).argmax(dim=1), targs)
def usm3_err_raw(preds,targs): return error_rate(preds[:,cfg(2):cfg(3)].softmax(dim=1).argmax(dim=1), targs)
def usm4_err_raw(preds,targs): return error_rate(preds[:,cfg(3):cfg(4)].softmax(dim=1).argmax(dim=1), targs)

# defining loss function for each robotic hand tools
def usm1_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs): return CrossEntropyLossFlat(reduction='mean')(preds[:,:cfg(1)], usm1_targs,**kwargs)
def usm2_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs): return CrossEntropyLossFlat(reduction='mean')(preds[:,cfg(1):cfg(2)], usm2_targs,**kwargs)
def usm3_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs): return CrossEntropyLossFlat(reduction='mean')(preds[:,cfg(2):cfg(3)], usm3_targs,**kwargs)
def usm4_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs): return CrossEntropyLossFlat(reduction='mean')(preds[:,cfg(3):cfg(4)], usm4_targs,**kwargs)

# defining combined loss
def combo_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs): 
    return usm1_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs)+usm2_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs)+usm3_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs)+usm4_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs)

# configuring metrics and loss for learner
metrics_cfg = [usm1_loss,usm2_loss,usm3_loss,usm4_loss,usm1_err,usm2_err,usm3_err,usm4_err, combo_err]

# error rate fns for inference and validation
def usm_err_raw(preds,targs): return error_rate(preds, targs)
def combo_err_raw(preds, targs): 
    return usm_err_raw(preds[:,:cfg(1)].softmax(dim=1),targs[0])+usm_err_raw(preds[:,cfg(1):cfg(2)].softmax(dim=1),targs[1])+usm_err_raw(preds[:,cfg(2):cfg(3)].softmax(dim=1),targs[2])+usm_err_raw(preds[:,cfg(3):cfg(4)].softmax(dim=1),targs[3])


codes = ["Background", "Foreground"]
        
# 
def get_image_mask(fn):
    f=Path(str(fn).replace('images', 'masks').replace('jpg','png'))
    return PILMask.create(f) 
    
def custom_accuracy(inp, targ):
    targ = targ.squeeze(1)
    return (inp.argmax(dim=1)==targ).float().mean()